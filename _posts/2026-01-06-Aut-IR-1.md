---
layout: post
title: "Automatización de Respuesta a Incidentes: Detección de Dominios Phishing con la API de VirusTotal"
date: 2026-01-06
categories: [automatizacion-ir]
permalink: /automatizacion-ir-python3/
---

# Automatización de Respuesta a Incidentes: Detección de Dominios Phishing con la API de VirusTotal

- <span class="solo-color-neon">Laboratorio creado en un entorno controlado, con mis propias máquinas virtuales y en un entorno totalmente aislado. </span>
- <span class="solo-color-neon">Por favor, no visites los dominios marcados como maliciosos en las capturas, ya que algunos podrían estar activos y podrías comprometer tu seguridad. La web comprometida ha sido extraída de PhishTank, una herramienta increíble para OSINT y lucha contra el fraude. Este laboratorio tiene un fin exclusivamente académico e ilustrativo. Repito, no lo visites. </span>
- <span class="solo-color-neon">No me responsabilizo del mal uso de este laboratorio. Queda prohibido usar parte o la totalidad del tutorial para usarlo en ordenadores de terceros.</span>
- <span class="solo-color-neon">Gracias por respetar estas condiciones.</span>

Hoy voy a realizar un laboratorio de respuesta a incidentes enriqueciendo los logs de un archivo en el que sólo hay dominios escritos. En un SOC, ir manualmente subiendo cada web una por una a <span class="solo-color-neon">VirusTotal</span> es un auténtico infierno. Eso es una pérdida de tiempo realmente grande, pudiendo automatizarse (de hecho, no creo que ninguna empresa suba a mano dominios a <span class="solo-color-neon">VirusTotal)</span>. Esta es una automatización muy simple para subir dominios a <span class="solo-color-neon">VirusTotal</span> y que esta devuelva el número de antivirus que lo detectan. Cualquiera que haya usado Python para consultar en <span class="solo-color-neon">VirusTotal</span> se da cuenta que es una tarea sencilla, porque la biblioteca <span class="solo-color-neon">request</span> nos da todo lo que necesitamos (gracias, creador). 

En esta ocasión voy a usar, como has deducido, la <span class="solo-color-neon">API de VirusTotal</span>. También he usado <span class="solo-color-neon">PhisTank</span> para extaer un dominio Phishing <span class="solo-color-neon">(te lo voy a marcar muy claramente para que en ningún caso lo busques en la web)</span>. El flujo es bastante sencillo e intuitivo. Lo primero que hay que hacer es importar las bibliotecas necesarias. Yo tengo 4 dominios en "resultados.txt" que está en el mismo directorio que mi script. No tiene mucho misterio, quizá lo más problemático es la creación de la cabecera. Yo en mi caso le estoy diciendo que me lo devuelva en formato JSON para poder leerlo todo como un diccionario y mi <span class="solo-color-neon">API KEY</span> (Bajo el rectángulo blanco, obviamente no iba a ponerla públicamente). Como estoy usando mi ordenador personal (hoy no he usado mis máquinas virtuales porque mi entorno de programación está en mi ordenador de uso diario) , he tapado también mi usuario para mayor seguridad. A continuación, pongo el código completo y la explicación: 

![vIRUSTOTAL](https://github.com/user-attachments/assets/f7d757a9-8df5-4b8d-a003-59a023a454b9)


He hecho que verifique el código de estatus <span class="solo-color-neon">HTTP</span>, en este caso es <span class="solo-color-neon">200</span>, o sea, que todo genial. En el caso de que salga otro código (<span class="solo-color-neon">429</span> es muy común, en este caso te estás pasando de número de peticiones. Recuerda que <span class="solo-color-neon">VirusTotal</span>, en su versión gratuita, sólo puedes subir <span class="solo-color-neon">4</span> peticiones por minuto). La variable <span class="solo-color-neon">dicvirustotal</span> va a internarse en el diccionario que me ha dado en <span class="solo-color-neon">JSON VirusTotal</span> (Primero entro en <span class="solo-color-neon">data</span>, luego en <span class="solo-color-neon">attributes</span>, luego en <span class="solo-color-neon">last_analysis_stats</span>). Como es muy posible que a lo mejor no exista ese valor (Por X motivos, no suele ser la regla general, pero hay que cubrirse las espaldas) uso el <span class="solo-color-neon">get</span>, que me permite asignar un valor vacío si no lo encuentra y no hacer que el programa se cierre con un error. En esta parte que hemos llegado, ya podemos extraer el número de antivirus que lo detectan como <span class="solo-color-neon">malicioso</span> (malicious), como <span class="solo-color-neon">sospechoso</span> (suspicious) y como <span class="solo-color-neon">inofensivo</span> (harmless). En este caso dependerá mucho de la persona que lo construya, porque ahora vamos con la lógica de <span class="solo-color-neon">"¿Hasta cuántos motores permitimos que lo marquen rojo para marcarlo como amenaza?"</span>. Hay gente o entornos donde la seguridad debe ser máxima (Pueden decir que con que detecten 1 o 2 es suficiente). Otros pueden ser más holgados y permitir más (8-9). En mi opinión, un número superior a 5 ya me hace saltar todas las alarmas. Existen los <span class="solo-color-neon">falsos positivos</span>, si algún antivirus marca algo como malicioso pero los demás están limpios, suele ser un <span class="solo-color-neon">falso positivo</span> (pero en pocos casos suele ser una variante nueva no reconocida, ándate con ojo). En mi caso elegí 5 porque es más flexible, pero en entornos de <span class="solo-color-neon">confianza cero</span> yo cambiaría 5 por 1, sin dudarlo, prefiriendo la seguridad a los <span class="solo-color-neon">falsos positivos</span>. El resultado es el siguiente:

![Script2](https://github.com/user-attachments/assets/0a92fbf6-ec78-4b36-a67d-5d3ee2f95a6f)

La primera web, debian[.]org es la web oficial de Debian, la segunda incibe[.]es es también oficial, es la web del instituto nacional de ciberseguridad en España, la tercer kern[.]org es el sitio oficial de linux para el desarrollo del kernel de Linux. La última, finovexprosoft[.]com es el<span class="solo-color-neon"> PHISHING</span>, mucho cuidado con esta, en ningún caso la visites. El resultado es que 9 motores lo detectan como <span class="solo-color-neon">malicioso</span>, por lo tanto, cumple nuestro filtro para ser detectado como <span class="solo-color-neon">peligroso</span>. Los demás, <span class="solo-color-neon">son oficiales y confiables</span>, ningún motor lo detecta como malicioso.

Quizá te has dado cuenta de la pausa de 20 segundos y si tienes una cuenta gratuita en <span class="solo-color-neon">VirusTotal</span>, te habrás dado cuenta de que con su <span class="solo-color-neon">API KEY</span> sólo tienes <span class="solo-color-neon">4</span> intentos por minuto, prefiero no hacerlos muy seguido y dejar un espacio entre subida y subida (El tiempo sería de 15 segundos si lo hacemos muy riguroso, pero siempre dejo algo de espacio por si las moscas). 

En realidad, este código puede <span class="solo-color-neon">mejorarse</span> (Incluir otros tipos de errores de código HTTP, poner un try/except para manejar cualquier tipo de error, funciones para escalar mejor el código... etc), pero en este caso sólo quería mostrar una versión funcional de cómo usar la <span class="solo-color-neon">API de VirusTotal</span> (lo cual, si trabajas en ciberseguridad, es obligatorio).

- <span class="solo-color-neon">Laboratorio creado:</span> 06/01/2026
- <span class="solo-color-neon">Laboratorio publicado:</span> 06/01/2026
