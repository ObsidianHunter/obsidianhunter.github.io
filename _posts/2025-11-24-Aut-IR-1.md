---
layout: post
title: "Automatización de Respuesta a Incidentes: Detección y Eliminación de Archivos sin Firma Digital"
date: 2025-11-24
categories: [automatizacion-ir]
permalink: /automatizacion-ir-python/
---

# Automatización de Respuesta a Incidentes: Detección y erradicación de archivos sin firma digital


He desarrollado un script en Python que monitorea específicamente la clave del registro -> <span class="solo-color-neon">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span>.
Si has trabajado con malware en Windows, sabes que esta es uno de sus sitios favoritos para establecer persistencia (pero no la única). El objetivo es simple, <span class="solo-color-neon">identificar archivos ejecutables que intenten cargarse automáticamente al inicio sin tener una firma digital válida. </span>

Elegí Python por encima de PowerShell principalmente porque me resulta más versátil para automatización. Python me permite trabajar cómodamente con el registro de Windows a través de winreg, gestionar procesos con <span class="solo-color-neon">psutil</span>, calcular hashes con <span class="solo-color-neon">hashlib</span>, y manipular archivos con <span class="solo-color-neon">shutil y os</span>, pero quien quiera usarlo para Powershell, pues para gustos los colores. Además, si en el futuro quiero integrar una API externa o incluso adaptar partes del código para otros sistemas, Python me lo pone bastante más fácil. En mi opinión, <span class="solo-color-neon">si estás considerando entrar en ciberseguridad, Python es el mejor lenguaje.</span>

**Algo importante que aprendí por las malas:** este script requiere ejecutarse con permisos de administrador. La primera vez que lo probé me llevé un buen rato depurando hasta que me di cuenta de que estaba ejecutando el programa sin los permisos adecuados (Tengo la costumbre del doble clic directamente). Así que nada, hay que ejecutarlo como adminastrador o no va a funcionar.

## Detección de archivos sin firma digital

<span class="solo-color-neon">Empezamos conectándonos a la clave del registro HKLM\...\Run y examinando cada valor almacenado ahí.</span> Para cada archivo ejecutable que encuentro, verifico si tiene una firma digital de una compañía reconocida. Si no la tiene, ese archivo va directo a mi lista de sospechosos.

```python
with open(registro,"a", encoding="utf-8", errors="replace") as log:
    log.write(f"==========Detecciones=======\n \n")
    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,r"SOFTWARE\\MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN",0, winreg.KEY_READ) as clavehklm:
        _,valores,_=winreg.QueryInfoKey(clavehklm)
        indice=0
        for indice in range(valores):
            try:
                nombre,valor,_=winreg.EnumValue(clavehklm,indice)
                valor=Decodificar(valor)
                valor=Limpiar(valor)
                compañia=compobtener(valor)
```
En mi caso, yo he creado antes funciones que me permiten tener una ruta limpia y segura. Por ejemplo, en el registro de windows, una ruta asociada a un valor puede tener elementos que no queremos al final de la cadena (/gui, -background), incluso podríamos ver <span class="solo-color-neon">variables de entorno típicas de windows </span> (%windir%, %programfiles%). Si intentas leer con Python una ruta así, va a aparecer como que no existe el archivo, por lo tanto, hay que decodificar (sustituir variables de entorno por sus rutas absolutas) y limpiar la ruta (nos interesa la ruta C:\.....\archivo.exe). <span class="solo-color-neon">Esa primera parte del código, lo que hace, es listar todos los valores que hay en la clave Run. </span>

## Eliminar valor del registro

<span class="solo-color-neon">En esta parte del código, mi función devuelve "Desconocido" cuando no hay una firma digital asociada al archivo</span>(en castellano, no hay ninguna compañía que haya firmado el archivo). Cuando la compañía es igual a Desconocido, se marca el archivo como malicioso. Una vez identificado el archivo malicioso, lo eliminamos de la clave del registro. Esto evita que el archivo se ejecute automáticamente la próxima vez que arranque el sistema, <span class="solo-color-neon">cortando drásticamente su mecanismo de persistencia.</span> También, se va a ir creando un log donde se van a ir guardando los datos de eliminación y futuros indicadores de compromiso.

```python
if compañia == "Desconocido":
                    ahora=datetime.datetime.now()
                    log.write(f"{ahora}: {nombre} -> {valor}\n")
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,r"SOFTWARE\\MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN",0,winreg.KEY_ALL_ACCESS) as Veliminar:
                        try:
                            winreg.DeleteValue(Veliminar,nombre)
                            log.write(f"{ahora}: {nombre} -> {valor} -> Ha sido eliminado correctamente.\n")
                            
                        except (FileNotFoundError, PermissionError, OSError):
                            log.write(f"{ahora}: {nombre} -> {valor} No Ha podido ser eliminado.\n")
```

## Eliminación del proceso

<span class="solo-color-neon">Dentro de la condición "if" de antes, seguimos husmeando en el sistema, identificando si ese proceso está en la lista de procesos. </span> En esta parte del código vamos a intentar matar el proceso. He usado la función kill porque, aunque es algo más agresiva, permite una mayor seguridad de eliminar procesos. Seguimos con la misma tónica, vamos documentando TODO, queremos saber tanto lo que está eliminando como lo que no.

```python
for proceso in psutil.process_iter():
                        try:
                            ruta = proceso.exe()
                            if ruta == valor:
                                    try:
                                        proceso.kill()
                                        log.write(f"{ahora}: {ruta} -> Proceso Terminado Correctamente. \n")
                                        

                                    except(psutil.AccessDenied, psutil.NoSuchProcess, Exception):
                                        log.write(f"{ahora}: {ruta} -> Proceso No Terminado. \n")
                                        
                            
                        except (psutil.AccessDenied, psutil.NoSuchProcess, Exception):
                            continue
```

## Mover el archivo a cuarentena y renombrar su extensión

<span class="solo-color-neon">Luego movemos el archivo a una ubicación segura donde no pueda ejecutarse accidentalmente. </span> La ejecución accidental puede darse con el archivo en cuarentena, por lo tanto, es obligatorio renombrar su extensión (¿Cuántas veces no hemos hecho doble clic sin querer en algún archivo que estábamos examinando? Tú y yo sabemos que muchas.). En este caso, yo lo que hago es renombrar su extensión con <span class="solo-color-neon">".cuarentena" </span>. Esto nos permite que, de llegar a ser un <span class="solo-color-neon">falso positivo</span>, el archivo puede ser restaurado a ejecutable sin problemas pero si es una sorpresa desagradable, no podamos ejecutarlo directamente. En esta parte del code, también voy extrayendo algunos <span class="solo-color-neon">IOC</span> (fecha de creación del archivo y la fecha de modificación.). Y sí, lo sé, soy muy poco original con el nombre de las variables.

```python
if os.path.isfile(valor):
                        CarpetaN = Path(r"C:\Cuarentena")
                        CarpetaN.mkdir(parents=True, exist_ok=True)
                        nombreprov=os.path.basename(valor)
                        nombrenoextension,_=os.path.splitext(nombreprov)
                        CarpetaN2=CarpetaN / f"{nombrenoextension}.cuarentena"
                        creacion=os.path.getctime(valor)
                        modificacion=os.path.getmtime(valor)
                        fechac = datetime.datetime.fromtimestamp(creacion)
                        fecham = datetime.datetime.fromtimestamp(modificacion)
                        creacion = fechac.strftime("%Y-%m-%d %H:%M:%S")
                        modificacion = fecham.strftime("%Y-%m-%d %H:%M:%S")
                        hash2=exhash(valor)
                        try:
                            shutil.move(valor,CarpetaN2)
                            log.write (f"{ahora}: Archivo {valor} movido correctamente a {CarpetaN} \n")
```

## Generación del informe

Y aquí viene la parte que, personalmente, creo que es la más importante: <span class="solo-color-neon">generamos un informe completo con todos los indicadores de compromiso.</span> Calculamos los hashes SHA256 y MD5 del archivo (yo ya tenía hecha la función para sacar <span class="solo-color-neon">los hashes del archivo</span>, una función llamada "exhash"), registramos las fechas de <span class="solo-color-neon">creación</span> y <span class="solo-color-neon">modificación</span>, y mapeamos la actividad en <span class="solo-color-neon">MITRE ATT&CK</span>. ¿Por qué sirven estos datos?. Necesitamos evidencia de TODO, no queremos eliminar algo y olvidarnos de ello, imagina que por error borras un archivo crítico..Necesitamos hashes, registros horarios y <span class="solo-color-neon">TTP</span> para poder evaluar si es un falso positivo o un verdadero positivo.

```python
                            log.write (f"\n \n ========METADATOS====== \n \n")
                            log.write (f"Fecha de creación: {creacion} \n")
                            log.write (f"Fecha de modificación: {modificacion} \n")
                            log.write (f"Hashes del archivo: {hash2} \n")
                            log.write (f"Táctica Mitre: TA0003 -> Persistencia \n")
                            log.write (f"Técnica Mitre: T1547 -> Boot or Logon Autostart Execution \n")
                        except shutil.Error:
                            log.write (f"{ahora}: El archivo {valor} no ha posido ser removido.\n")
                            continue


            except (FileNotFoundError, PermissionError, OSError):
                continue
```


<span class="solo-color-neon">La inmensa mayoría del malware no tiene firma digital legítima</span>. Los atacantes tienen muchas dificultades para obtener certificados de compañías reconocidas para firmar sus herramientas maliciosas (Tampoco están muy preocupados por ello, la verdad). Su función es infectar, no perder tiempo con papeleos de registros. Por eso el que no aparezca una firma digital es un indicador de riesgo <span class="solo-color-neon">bastante fiable</span>, especialmente cuando hablamos de persistencia en el registro y muy, muy bueno para entornos de <span class="solo-color-neon">confianza cero</span>.

Y bueno, a ver, no todo lo que carece de firma es malicioso. <span class="solo-color-neon">Hay software legítimo sin firmar, sobre todo utilidades pequeñas o herramientas desarrolladas internamente</span>. Pero cuando ves un ejecutable intentando persistir en el registro sin firma digital, investigar se vuelve una tarea indispensable.

<span class="solo-color-neon">Con esto, la velocidad de respuesta aumenta drasticamente.</span> En lugar de esperar a que un analista revise logs y detecte el patrón manualmente, el script actúa inmediatamente. Contiene la amenaza antes de que pueda hacer más daño y genera toda la documentación necesaria para el análisis forense posterior. En mi experiencia probándolo, la diferencia entre detección manual y automatizada puede ser de horas, y en seguridad ese tiempo importa. De hecho, con este mismo script, detecté en el ordenador de un familiar un troyano (Un Zbot, para ser exactos) que llevaba ahí semanas escondido, sólo probaba el archivo que pudiera funcionar en otros entornos (Un golpe de suerte, no cabe duda.)

Y aquí os dejo una de las pruebas que hice:

```python
==========Detecciones=======
 
2025-11-22 19:18:00.108305: programa -> C:\programa.exe
2025-11-22 19:18:00.108305: programa -> C:\programa.exe -> Ha sido eliminado correctamente de la clave run.
2025-11-22 19:18:00.108305: C:\programa.exe -> Proceso Terminado Correctamente. 
2025-11-22 19:18:00.108305: Archivo C:\programa.exe movido correctamente a C:\Cuarentena 

 
 ========METADATOS====== 
 
Fecha de creación: 2025-11-21 10:59:03 
Fecha de modificación: 2025-11-21 10:59:03 
Hashes del archivo: SHA256=dc647ecbb71ba51d62fef7c4718fb644355d6f4893e86c21c96b67f475f0bef1, MD5=4405696872b1928adb85859c8f9d90dd
Táctica Mitre: TA0003 -> Persistencia 
Técnica Mitre: T1547 -> Boot or Logon Autostart Execution 
```

Todo documentadito (con hora, iocs, qué ha eliminado y qué no...). Programa es el nombre del valor de la clave run con la que cargaba.

## Mejoras futuras que tengo en mente

- Lo primero sería implementar un <span class="solo-color-neon">bucle infinito</span> que mantenga el monitoreo activo constantemente.

- No sólo la persistencia reside en esa clave. Hay muchas otras ubicaciones en el registro donde el malware intenta persistir: <span class="solo-color-neon">RunOnce, servicios, tareas programadas...</span> Crear una lista completa para monitorearlas todas aumentaría bastante la efectividad del script.

- La mejora que considero más crítica sería integrar <span class="solo-color-neon">la API de Virustotal</span>. Antes de eliminar un archivo, podríamos enviarlo para análisis y obtener una segunda opinión de múltiples motores antivirus. <span class="solo-color-neon">Esto reduciría falsos positivos considerablemente </span> y nos daría contexto adicional sobre qué familia de malware estamos viendo exactamente. EL problema aquí, puede ser que el archivo sea un malware y los motores antivirus todavía no lo marquen así, lo que le quitaría mucho poder al script.

- Implementar una <span class="solo-color-neon">lista blanca</span> de aplicaciones legítimas conocidas que no tienen firma digital pero son de confianza. Nadie quiere ser la persona que envió a <span class="solo-color-neon">cuarentena</span> una herramienta crítica del sistema por error, créeme (De verdad, créeme, no quieres ser esa persona).

<span class="solo-color-neon">Laboratorio creado: 23/11/2025</span>

<span class="solo-color-neon">Laboratorio publicado: 24/11/2025</span>
