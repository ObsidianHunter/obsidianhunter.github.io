---
layout: post
title: "Automatización de Respuesta a Incidentes: Detección y Erradicación de Fuerza Bruta"
date: 2025-11-29
categories: [automatizacion-ir]
permalink: /automatizacion-ir-python2/
---

Hoy, voy a enseñarte cómo realizar un <span class="solo-color-neon">playbook automatizado para bloquear ataques de fuerza bruta mediante ssh con Python </span>. Es un código simple y la idea que se persigue es la siguiente... Si un usuario intenta mediante ssh (conexión remota) conectarse a mi ordenador, voy a intentar contar más de <span class="solo-color-neon">5 intentos de inicio de sesión fallidos y bloquear la ip en mi iptables </span> (lo siento, entusiastas de Windows, hoy le toca a Linux). El principal objetivo es reducir a segundos un trabajo que podría llevar fácilmente 10,15, 20 minutos... La conexión vía ssh es la más común en movimientos laterales y si un usuario falla su contraseña más de 5 veces, lo más normal es que sea alguien tratando de acceder de manera sospechosa. Si bien este script lee las últimas 50 líneas del archivo auth.log y sólo permite 5 intentos de inicio de sesión fallidos, <span class="solo-color-neon">cada persona debe adaptarlo a su entorno </span> (quizá, una persona que genera muchos eventos en auth.log 50 líneas se le queden muy cortas o una empresa que cambia constantemente las contraseñas con 5 intentos se le queda en muy poco margen de maniobra). Tanto en la vida como en los logs, hay que saber adaptarse a las circunstancias. Recuerda ejecutar esto en máquinas virtuales propias y nunca en un entorno de producción.

Voy a empezar diciendo lo que hace el código, sabiendo que mi oratoria no es de un premio nobel de literatura. Pego y explico:

```py
from collections import Counter
import re
import subprocess
import datetime

IpFuerzaB = Counter()

detectar = re.compile(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')

with open("/var/log/auth.log") as log:
        lineas= log.readlines()[-50:]
        for numero,linea in enumerate(lineas):
            linea = linea.lower()                            
            if "authentication failure" in linea and "rhost=" in linea:
                coincidencia = detectar.search(linea)
                if coincidencia:
                    ip = coincidencia.group(1)
                    IpFuerzaB[ip] += 1
with open ("archivo.txt","a",encoding="utf-8") as archivo:
    for ips, fallo in IpFuerzaB.items():
        if fallo > 5:
            try:
                BLoqueado=subprocess.run(["sudo","iptables","-L","-n"], capture_output=True, text=True)
                if ips in BLoqueado.stdout:
                    continue
                ahora=datetime.datetime.now()
                archivo.write(f" {ahora}: Intento de fuerza bruta ({fallo} fallos) desde la IP:  {ips} \n")
                subprocess.run(["sudo", "iptables", "-A", "INPUT", "-s",ips,"-j","DROP"], check=True)
                BLoqueado=subprocess.run(["sudo","iptables","-L","-n"], capture_output=True, text=True)
                if ips in BLoqueado.stdout:
                    ahora=datetime.datetime.now()
                    archivo.write(f"{ahora}: La ip siguiente ha sido bloqueada con éxito ->  {ips} \n")
                else:
                    ahora=datetime.datetime.now()
                    archivo.write(f"{ahora}: La ip siguiente NO ha podido ser bloqueada -> {ips}\n")
            except subprocess.CalledProcessError:
                continue
``` 

En este caso, voy a usar Counter. Con Counter vpy a contar la cantidad de ip que hay en el log (Bueno, en el log no, en las 50 últimas líneas, que hay que explicarlo todo). Voy a hacer un regex muy simple que permita pillar <span class="solo-color-neon">todo lo que tenga el formato de una IP </span>. Bien, voy a leer el fichero auth.log de la ruta /var/log (entre otras cosas, es el archivo de las autenticaciones), <span class="solo-color-neon">pero voy a coger sólo lás últimas 50 líneas del log</span> con:
```python
lineas= log.readlines()[-50:]
```

Continuo con un bucle sencillo para recorrer esas 50 líneas y pongo la línea en minúsculas (el fichero auth.log es bastante determinista pero, por si las moscas, prefiero comparar todo en minúsculas). Ahora empiezo a encontrar coincidencias:

```py
if "authentication failure" in linea and "rhost=" in linea:
```

<span class="solo-color-neon">Es cutre, pero efectivo</span>. Voy a ver si la línea contiene la frase "authentication failure" y también "rhost=" (porque aparece justamente así en auth.log, en rhost va a aparecer la ip implicada.).

```py
                coincidencia = detectar.search(linea)
                if coincidencia:
                    ip = coincidencia.group(1)
                    IpFuerzaB[ip] += 1
```

Aquí hago varias cosas, la primera, con el regex <span class="solo-color-neon">busco todo lo que sea una ip</span> (o por lo menos, el formato de una ip, lo mismo se cuela otras cosas, pero en auth.log es muy raro) y lo guardo en la variable coincidencia. Si coincidencia tiene una ip, lo voy a cazar con el coincidencia.group(1). <span class="solo-color-neon">Ya tengo la ip en ip</span> (valga la redundancia) y le voy a sumar al diccionario Counter un +1 por la dirección ip que ha cogido. En este caso, si vuelve a coger otra más, volvería a sumarle uno, y el diccionario sería ya <span class="solo-color-neon">192.168.0.200 -> 2</span>. Counter es extremadamente útil para esto, ya que maneja y almacena todas las ip por sí mismo (quitándome muchísima carga de trabajo, que se agradece.)

```py
with open ("archivo.txt","a",encoding="utf-8") as archivo:
    for ips, fallo in IpFuerzaB.items():
        if fallo > 5:
            try:
                BLoqueado=subprocess.run(["sudo","iptables","-L","-n"], capture_output=True, text=True)
                if ips in BLoqueado.stdout:
                    continue
                ahora=datetime.datetime.now()
                archivo.write(f" {ahora}: Intento de fuerza bruta ({fallo} fallos) desde la IP:  {ips} \n")
                subprocess.run(["sudo", "iptables", "-A", "INPUT", "-s",ips,"-j","DROP"], check=True)
                BLoqueado=subprocess.run(["sudo","iptables","-L","-n"], capture_output=True, text=True)
                if ips in BLoqueado.stdout:
                    ahora=datetime.datetime.now()
                    archivo.write(f"{ahora}: La ip siguiente ha sido bloqueada con éxito ->  {ips} \n")
                else:
                    ahora=datetime.datetime.now()
                    archivo.write(f"{ahora}: La ip siguiente NO ha podido ser bloqueada -> {ips}\n")
            except subprocess.CalledProcessError:
                continue
``` 

La parte del code ma´s sencilla. En este caso, voy a abrir un archivo en modo escritura y lo llamaré archivo y voy a recorrer el bucle del diccionario counter (va a devolver dos elementos, la ip y el número de fallos (que hee estado contando con el +=1)). <span class="solo-color-neon">Primero hago un proceso de verificación de las ip que tiene iptables y lo paso a "Bloqueado"</span>. Si la ip está en Bloqueado, nada, continuo <span class="solo-color-neon">(porque no quiero que en en log se repita infinitamente una línea)</span>. Si no está, Creo el aviso, ejecuto el iptables para bloquear esa ip y listo. Hago un segundo repaso volviendo a cargar las reglas de IPTables, en este caso, si está la ip, ya puedo decir que se ha bloqueado correctamente pero si no está va a salir el fallo de que no ha podido ser bloqueada. <span class="solo-color-neon">Ojo con el except final</span>, si no se ejecuta el archivo como administrador va a a llamar a eso y no va a hacer absolutamente nada.

Voy a poner un trozo de captura de una de las partes de mi auth.log para que veais lo que es. En este caso, <span class="solo-color-neon">ayer me dediqué con Kali a generar un poco de eventos de autenticación fallidos en mi máquina virtual de Mint</span> (nada que involucre ataques de fuerza bruta o diccionario, simple y llanamente con el ssh poniendo contraseñas aleatorias). Como ves, salen algunos eventos de autenticación fallidos. 

![CapturaAuth](https://github.com/user-attachments/assets/6cb5ccdf-3a27-45c4-9afa-19b28d2d1603)


Bien, ahora ejecuto el .py con privilegios de administrador desde la consola.

![Capturacli](https://github.com/user-attachments/assets/f9dbd2be-4a80-4660-a6a1-d24e061840a6)


Y este es el resultado en archivo.txt:


![CapturaArchivo](https://github.com/user-attachments/assets/ddca8e64-1e11-41a7-a307-c58f7b691ab0)


Si quisiera un detector que monitorizara todo de manera constante, <span class="solo-color-neon">podría hacer un bucle infinito while</span> y alguna excepción para escapar si el usuario lo quisiera. En mi caso me es un poco indiferente, ya que tengo otras herramientas mucho mejores para detectarlos, pero como script rápido que se escribe en 20 minutos, me vale para mostrar esta automatización de un bloqueo <span class="solo-color-neon">a un ataque de fuerza bruta.</span>

Estoy podría ser una parte de algún HIDS o un HIPS (de hecho, yo lo estoy implementando con la misma lógica y como parte de un HIDS) y este script puede ser de mucha utilidad.
